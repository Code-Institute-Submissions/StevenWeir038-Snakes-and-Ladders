# Testing
**A student's inner voice, providing feedback of current approach/understanding to his mentor to develop improvements for future assessors.**

Using the [flowchart](docs/wireframes/flowchart.png "Game logic flowchart") as a guide, an incremental approach was used to build the application.

## IDE tools
The problems tab beside the terminal in gitpod provided warnings for code issues.  There are a few categories. Those of primary concern were highlighted red and needed to be resolved.
This was consulted every after writing several lines of code and was especially useful for resolving syntax errors and checking for unused variables.

*Terminal output*

![problems-code-issues](docs/readme/problems-code-issues.png "problems-code-issues")

## Game setup
### Casting
Care was taken when accepting inputs from the user.  As these default to a *string* format they needed to be converted to an *integer* as they were to be used in a loop to create the validated number of players.

``` python
# Immediately convert string input from user to an integer
player_count = int(input("Enter number of players between 2 and 4:\n"))
```

``` python
for p in range(1, player_count + 1):
    if p == 1:
        print("player one")  # testing
        player_list.append("P1 red")
    elif p == 2:
```

### Validating player counts
Print statements with f strings were used throughout to give human readible feedback on the terminal.  This is demonstrated when the user enters a value outside the range of players needed for the game.

``` python
def validate_player_count(player_count):
    """
    Check number of players supplied from game_setup() function
    is an integer >= 2 and <= 4
    """
    try:
        if player_count < 2 or player_count > 4:
            raise ValueError
    except ValueError:
        print(f"You entered {player_count} player(s). Try again...")
```

*Terminal output*

![game-setup-1-terminal](docs/readme/game-setup-1.png "game-setup-1-terminal")

### Verifying an object was created for the assigned number of players
My current understanding of Python is that it is built of list, dictionary and class structures.  As such, my challenge for this project was to:
- build a list of players based on a validated number of players entered by the user
- populate that list with predetermined player/pawn color values. (This could easily have been an inputted name)
- using dictionary comprehension, build a dictionary based of the above list.  Each key is the same as each list value. As I wanted to follow an OOP paradigm the corresponding values were to be *instances* of a *Player* class.
- each instance can be accessed by their respective key (which serves as the iterable).  Multiple methods and attributes can be added for improved versatility/future development.  For an MVP, only the pawn_color and curr_position are present.

The **Player** class
``` python
class Player:
    """
    Player class
    """

    def __init__(self, pawn_color, curr_position=0):
        # instance properties
        self.pawn_color = pawn_color
        self.curr_square = curr_position

    # instance methods
    def location(self):
        """
        return a statement representing this object's:
        (plan is to update the VALUE ingame with dice roll or landing on a \
        snake head/ladder foot to simulate player's current position)
        """
        player_location = {f"{self.pawn_color} pawn is on square \
        {self.curr_square} "}

        return player_location
```

Each object has it's unique place in memory (proving its instance).

*Terminal output*

![verify-object-creation-terminal](docs/readme/verify-object-instance-of-a-class-creation.png "verify-object-creation-terminal")

## Game
### Considering data passing between functions
A conceptual leap I have made is to consider the structure of data that flows from one function to another.  Its must be compatible.  In this example, the game_setup() function returns a dictionary which is stored the *players* variable. By passing the players variable to the snl_game() function, we are providing the snl_game(players) function the dictionary generated by the game_setup() function.  Thus the player dictionary can now be manipulated within the snl_game() function.

``` python
players = game_setup()  # players = dict of players rtnd from game_setup()
snl_game(players)  # pass 'players' dictionary to the game
```


### Setting up a forever loop between players
Setting up an infinite loop is as simple as typing `while True:` though this isn't overly useful for debugging as you have to select *ctrl + c* simultaneously to stop.  As a computer is fast you can miss some important output on the terminal that is relevant to the debugging process.  A solution is to comment out the infinite command using *ctrl + /* and replace with a loop that repeats several times only.

``` python
def snl_game(players):
"""
Iterate players, loop through each until win condition met
"""
# infinite loop needed to keep game live until victory condition met
# while True:
for i in range(1, 11):  # testing for 10 turns
```
*Terminal output*

![verify-forever-player-loop-terminal](docs/readme/verify-forever-player-loop.png "verify-forever-player-loop-terminal")


### Testing for player landing on SNAKE_HEAD or LADDER_FOOT
If ladder and snake functionality is working correctly, movement on board is greater than a six as per each dice roll.  This is evidenced with f strings and their return to terminal.
``` python
    if new_position in SNAKE_HEAD:
        new_position = SNAKE_HEAD[new_position]
        print(f"{player_ID} landed on a SNAKE_HEAD and moves to {new_position}")
    elif new_position in LADDER_FOOT:
        new_position = LADDER_FOOT[new_position]
        print(f"{player_ID} landed on a LADDER_FOOT and moves to {new_position}")
    return new_position
```

*SNAKE_HEAD proof from terminal output*

![movement-snake-head-proof](docs/readme/movement-snake-head-proof.png "movement-snake-head-proof")

*LADDER_FOOT proof from terminal output*

![movement-ladder-foot-proof](docs/readme/movement-ladder-foot-proof.png "movement-ladder-foot-proof")

As you can see, the snake and ladder functionality overrides the basic move as the code lines are after `new_position = curr_position + roll_num`.  The trick being employed here revolves around *in*.  If the current player's position value equals the *in* *'key'* value, then the current position value becomes the *value* of the key in SNAKE_HEAD or LADDER_FOOT dictionary.

### Testing for first player reaching square 100
With the above game mechanics working, we now need to end the game when the first player sucessfully reaches square 100.
This is done by passing the player object to the check_win() function.  If this function returns `true` (which is stored in `winner` variable in snl_game function, then the game ends.  

``` python
def check_win(player_ID, player_instance):
    if player_instance.curr_square >= 100:
        print(f"Player '{player_ID}' wins!\n")
        return True
```


``` python
winner = check_win(player_ID, player_instance)
if winner:
    exit()
```

*Terminal output*

![winner](docs/readme/winner.png "winner")


### Testing for a player rolling a six
If a player hasn't satisfied the win condition, the application should then check if they are eligible for another turn by rolling a six as stipulated in the game rules.
One way for the game to know this is to add another attribute to the player class instance called `extra_roll` defaulted to `False` which tells the game each turn has only one roll of the dice unless told otherwise.
Passing the `player_instance` into the `roll_dice` function enables us to change the value of this extra attribute between `True` or `False` depending on the value rolled.  
As each player instance has its own place in memory, this new attribute can be used elsewhere without having to change the integer value output returned from roll_dice() to the turn() function. 
We just need to pass the player_instance from snl_game() to turn() to then make it accessible to roll_dice().

The updated roll_dice() function
``` python
def roll_dice(player_instance):
    roll = random.randint(1, 6)
    # ternary expression to evaluate True or False
    another_turn = True if roll == 6 else False
    # assign bool value of another_turn variable to player_instance attribute
    player_instance.extra_roll = another_turn
    print(f"Testing - player_instance.extra_roll value = {player_instance.extra_roll}")
    return roll
```

#### Stay the course
After checking for a winner in `snl_game()`, the following was added to enable the same player to have another turn.

``` python
extra_roll = player_instance.extra_roll
if extra_roll = True
    ...
```

Testing shows this actually cannot work without a GoTo type command which is bad structure.  An inner loop shouldn't be responsible for how an outer loop behaves. 
One attempt to solve this problem was to incorporate the value of the player_instance extra_roll attribute into the outer loop.  Doing so prevented the program from running correctly when the extra_roll value evaluated each player_instance extra_roll attribute to False.  In the example below only `P3 blue` repeated.

![extra-roll-not-working](docs/readme/extra-roll-not-working.png "extra-roll-not-working")

After this setback, I settled on nesting another loop.  Each turn must iterate at least once independent of the extra_roll value.  The innermost loop was different in that it ran only when extra_roll evaluated to True.

CHECK IN WITH TIM - IS THIS IS THE MOST VIABLE APPROACH? - D.R.Y *et al*.

``` python
for player_id, player_instance in players.items():
    # key is the player iterable, value is the Player object instance
    # establish current player's location on board and
    # assign the object attribute to 'curr_position' using .notation
    curr_position = player_instance.curr_square
    print(f"Player '{player_id}' current location is square '{curr_position}'.")  # testing
    # now pass curr_position variable to turn() function to process
    # the players new location based off their next dice roll
    new_position = turn(player_id, player_instance, curr_position)
    print(f"player '{player_id}' rolled a six value is '{player_instance.extra_roll}'.")
    # update player instance attribute with returned value from turn()
    player_instance.curr_square = new_position  # testing
    print(f"Player '{player_id}' new location is square '{player_instance.curr_square}'.\n")  # testing

    # check if win condition met
    winner = check_win(player_id, player_instance)
    if winner:
        exit()
    else:
        # check if player rolled a six.  Default is False,
        extra_roll = player_instance.extra_roll
        if extra_roll is True:
            ...
```

*Terminal output showing an iteration of a loop repeats*

![repeat-iteration](docs/readme/repeat-iteration.png "repeat-iteration")

### Next steps
We now have a text based simulation of the game.  It is useful to a developer or data scientist though it isn't an interactive game for a user.
To achieve this we need to provide:
- user prompts to roll the dice for each player
- a representation of the board with human interpretive feedback
- a way to differentiate each turn so as not to overwhelm the user


[Return to README.md](README.md)